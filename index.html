<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backgammon (שש-בש) - Local 2 Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Phosphor Icons for game elements -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
        /* General Setup */
        :root {
            --board-color: #583c27; /* Dark Brown Wood */
            --checker-p1: #f87171; /* Red */
            --checker-p2: #3b82f6; /* Blue */
            --point-dark: #654321; /* Darker Brown */
            --point-light: #8b6b4e; /* Lighter Brown */
            --bar-color: #4b3420; /* Bar Color */
            --highlight-color: #facc15; /* Yellow/Gold Highlight */
            font-family: 'Inter', sans-serif;
        }

        /* Board Container and Responsive Grid */
        #game-container {
            width: 100%;
            max-width: 900px;
            margin: 20px auto;
            border: 12px solid var(--bar-color);
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            background-color: var(--board-color);
        }

        #board {
            display: grid;
            grid-template-columns: repeat(13, 1fr); /* 6 points + 1 bar + 6 points */
            gap: 0;
            padding: 0;
            position: relative;
            user-select: none;
        }

        /* The Bar (center column) */
        #bar {
            background-color: var(--bar-color);
            border-left: 2px solid #332211;
            border-right: 2px solid #332211;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            grid-column: 7;
            z-index: 10;
        }
        
        /* Halves of the board */
        .board-half {
            grid-column: span 6;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0;
        }

        /* Point (Triangle) Styling */
        .point {
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 250px; /* Base height for desktop */
            min-height: 120px; /* Min height for mobile */
            padding: 0 2px;
        }
        
        /* Mobile Adjustments */
        @media (max-width: 768px) {
             .point {
                height: 150px; 
             }
             .dice {
                width: 30px !important;
                height: 30px !important;
                font-size: 1rem !important;
             }
             #game-controls button {
                padding: 0.5rem 1rem !important;
                font-size: 0.875rem !important;
             }
        }

        /* Top Points (Points 13-24) */
        #top-row .point {
            justify-content: flex-start;
        }
        
        /* Bottom Points (Points 1-12) */
        #bottom-row .point {
            transform: scaleY(-1); /* Flip the triangle visually */
            justify-content: flex-start;
        }
        #bottom-row .checker {
            transform: scaleY(-1); /* Flip the checker back */
        }

        /* Triangle Shape (CSS only) */
        .point::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 250px solid var(--point-dark); /* Base height */
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            transition: all 0.2s;
        }
        #bottom-row .point::before {
            border-bottom: none;
            border-top: 250px solid var(--point-dark);
        }

        /* Alternating Point Colors */
        .point:nth-child(even)::before {
            border-color: var(--point-light);
        }
        
        /* Checker Styling */
        .checker {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            position: relative;
            z-index: 20;
            margin-bottom: -15px; /* Overlap for stacking */
            transition: all 0.3s ease;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .checker.p1 {
            background-color: var(--checker-p1);
        }
        
        .checker.p2 {
            background-color: var(--checker-p2);
        }
        
        .checker:hover:not(.stacked) {
            transform: scale(1.1) translateY(-5px);
            z-index: 30;
        }

        /* Stacking Counter for more than 5 checkers */
        .checker.stacked {
            height: 40px;
            width: 40px;
            cursor: default;
        }
        
        /* Highlight on selected or valid move */
        .point.selected::before {
            border-bottom-color: var(--highlight-color);
            border-top-color: var(--highlight-color);
        }
        .point.valid-move::before {
            border-bottom-color: #10b981; /* Emerald */
            border-top-color: #10b981;
            box-shadow: 0 0 15px #10b981;
        }
        .checker.selected {
            border: 4px solid var(--highlight-color);
            box-shadow: 0 0 15px var(--highlight-color);
            transform: scale(1.2);
        }

        /* The Bar (Bar points for P1 and P2) */
        #bar-p1, #bar-p2 {
            min-height: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 0;
            overflow: hidden;
            position: relative;
        }
        #bar-p1 { justify-content: flex-end; }
        #bar-p2 { justify-content: flex-start; }
        .bar-checker {
            margin: 5px 0;
        }
        
        /* Off-Board (Bearing Off) Areas */
        #off-p1, #off-p2 {
            background-color: rgba(255, 255, 255, 0.1);
            grid-column: 14;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-left: 6px solid #facc15;
        }
        #off-p1 { justify-content: flex-start; }
        #off-p2 { justify-content: flex-end; }
        .off-count {
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
            margin: 5px 0;
            padding: 5px;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.3);
        }

        /* Control Panel */
        #game-controls {
            background-color: #374151;
            padding: 1.5rem;
            border-radius: 0 0 15px 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        
        #current-player-info {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            padding: 10px 20px;
            border-radius: 10px;
            text-shadow: 1px 1px 2px #000;
        }
        #current-player-info.p1 { background-color: var(--checker-p1); }
        #current-player-info.p2 { background-color: var(--checker-p2); }

        #roll-dice-btn, #end-turn-btn {
            background-color: #10b981; /* Emerald */
            color: white;
            padding: 0.75rem 2rem;
            font-size: 1.25rem;
            font-weight: bold;
            border-radius: 9999px;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.4);
        }

        #roll-dice-btn:hover:not(:disabled), #end-turn-btn:hover:not(:disabled) {
            background-color: #059669;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(16, 185, 129, 0.6);
        }
        #roll-dice-btn:disabled, #end-turn-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        /* Dice Display */
        #dice-display {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            min-height: 50px;
        }
        .dice {
            width: 40px;
            height: 40px;
            background-color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--highlight-color);
            transition: transform 0.2s;
        }
        .dice.used {
            background-color: #ccc;
            opacity: 0.6;
            text-decoration: line-through;
            border: 2px dashed #999;
        }

        /* Message Box */
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
            z-index: 1000;
            text-align: center;
            max-width: 90%;
            display: none;
            flex-direction: column;
            gap: 15px;
        }
        #message-box h2 {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        #message-box button {
            background-color: var(--highlight-color);
            color: #333;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        #message-box button:hover {
            background-color: #eab308;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">

    <div id="game-container">
        
        <div id="board">
            
            <!-- Top Half (Points 13-24) -->
            <div id="top-row" class="board-half">
                <!-- Points 13 through 24 (represented visually left to right: 24 to 13) -->
            </div>

            <!-- The Bar -->
            <div id="bar" class="grid grid-rows-2">
                <div id="bar-p2" class="flex flex-col items-center justify-start border-b border-gray-600">
                    <p class="text-xs text-white/50 mb-1">P2 Bar</p>
                </div>
                <div id="bar-p1" class="flex flex-col items-center justify-end border-t border-gray-600">
                    <p class="text-xs text-white/50 mt-1">P1 Bar</p>
                </div>
            </div>

            <!-- The Off-Board Area -->
            <div id="off-board" class="grid grid-rows-2 col-start-14 col-end-14">
                <div id="off-p2" class="min-h-1/2 flex-1 border-b border-gray-600">
                    <i class="ph-bold ph-flag text-blue-400 text-3xl"></i>
                    <span id="p2-off-count" class="off-count">0</span>
                </div>
                <div id="off-p1" class="min-h-1/2 flex-1 border-t border-gray-600">
                    <span id="p1-off-count" class="off-count">0</span>
                    <i class="ph-bold ph-flag text-red-400 text-3xl"></i>
                </div>
            </div>
            
            <!-- Bottom Half (Points 1-12) -->
            <div id="bottom-row" class="board-half">
                <!-- Points 12 through 1 (represented visually left to right: 1 to 12) -->
            </div>

        </div>

        <!-- Control Panel -->
        <div id="game-controls">
            <div id="current-player-info" class="p1">
                Player 1's Turn
            </div>
            
            <div class="flex flex-col items-center gap-4">
                <button id="roll-dice-btn" onclick="rollDice()">
                    <i class="ph-bold ph-dice text-2xl align-middle mr-2"></i>
                    Roll Dice
                </button>
                <button id="end-turn-btn" onclick="endTurn()" disabled>
                    <i class="ph-bold ph-check-circle text-2xl align-middle mr-2"></i>
                    End Turn
                </button>
            </div>

            <div id="dice-display">
                <!-- Dice will be injected here -->
            </div>
            
            <p id="game-message" class="text-sm text-yellow-300 font-medium"></p>
        </div>

    </div>
    
    <!-- Custom Alert/Message Box -->
    <div id="message-box">
        <h2 id="message-title"></h2>
        <p id="message-text"></p>
        <button onclick="hideMessage()">OK</button>
    </div>

    <script>
        // --- GAME STATE AND INITIALIZATION ---
        
        // The game state array represents the 24 points, plus the bar and off-board areas.
        // Array index 0 is P1 Off-Board, 25 is P2 Off-Board.
        // Index 26 is P1 Bar, 27 is P2 Bar.
        // Points 1-24 are indexed 1 to 24.
        const BOARD_STATE = new Array(28).fill(0); 

        // Initial setup for Backgammon:
        // P1 (Red): Moves from 1 to 24 (clockwise)
        // P2 (Blue): Moves from 24 to 1 (counter-clockwise)
        
        // Point: [Player, Count]
        const INITIAL_SETUP = {
            1: [1, 2], 
            6: [2, 5],
            8: [2, 3],
            12: [1, 5],
            13: [2, 5],
            17: [1, 3],
            19: [1, 5],
            24: [2, 2],
            26: [0, 0], // P1 Bar
            27: [0, 0], // P2 Bar
            0: [0, 0],  // P1 Off
            25: [0, 0] // P2 Off
        };

        let currentPlayer = 1; // 1 for Player 1 (Red), 2 for Player 2 (Blue)
        let dice = []; // Holds the rolled dice values (e.g., [3, 5])
        let movesAvailable = []; // Holds the current available dice values for moves
        let selectedChecker = null; // Point index of the selected checker (1-24, or 26/27 for bar)
        let movesMade = 0; // Track how many moves were completed this turn

        const PLAYER_INFO = {
            1: { color: 'p1', bar: 26, off: 0, homeStart: 1, homeEnd: 6, moveDir: 1, name: 'Player 1 (Red)' },
            2: { color: 'p2', bar: 27, off: 25, homeStart: 19, homeEnd: 24, moveDir: -1, name: 'Player 2 (Blue)' }
        };

        // --- DOM ELEMENTS ---
        const boardEl = document.getElementById('board');
        const topRowEl = document.getElementById('top-row');
        const bottomRowEl = document.getElementById('bottom-row');
        const barP1El = document.getElementById('bar-p1');
        const barP2El = document.getElementById('bar-p2');
        const diceDisplayEl = document.getElementById('dice-display');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const endTurnBtn = document.getElementById('end-turn-btn');
        const playerInfoEl = document.getElementById('current-player-info');
        const gameMessageEl = document.getElementById('game-message');
        const p1OffCountEl = document.getElementById('p1-off-count');
        const p2OffCountEl = document.getElementById('p2-off-count');

        // --- CORE GAME FUNCTIONS ---

        function initializeGame() {
            // Setup the board state based on INITIAL_SETUP
            for (let i = 1; i <= 24; i++) {
                if (INITIAL_SETUP[i]) {
                    BOARD_STATE[i] = { player: INITIAL_SETUP[i][0], count: INITIAL_SETUP[i][1] };
                } else {
                    BOARD_STATE[i] = { player: 0, count: 0 };
                }
            }
            // Setup bar and off-board states
            BOARD_STATE[PLAYER_INFO[1].bar] = { player: 1, count: 0 };
            BOARD_STATE[PLAYER_INFO[2].bar] = { player: 2, count: 0 };
            BOARD_STATE[PLAYER_INFO[1].off] = { player: 1, count: 0 };
            BOARD_STATE[PLAYER_INFO[2].off] = { player: 2, count: 0 };
            
            drawBoard();
            updatePlayerInfo();
            gameMessageEl.textContent = "Welcome! Player 1 rolls first.";
        }

        function drawBoard() {
            topRowEl.innerHTML = '';
            bottomRowEl.innerHTML = '';
            barP1El.innerHTML = `<p class="text-xs text-white/50 mt-1">P1 Bar</p>`;
            barP2El.innerHTML = `<p class="text-xs text-white/50 mb-1">P2 Bar</p>`;
            
            // Render Points 1-24
            for (let i = 24; i >= 1; i--) {
                const pointEl = createPointElement(i, BOARD_STATE[i]);
                if (i >= 13) {
                    topRowEl.appendChild(pointEl);
                } else {
                    bottomRowEl.appendChild(pointEl);
                }
            }

            // Reverse the bottom row for correct visual order (12 to 1)
            const bottomChildren = Array.from(bottomRowEl.children);
            bottomRowEl.innerHTML = '';
            bottomChildren.reverse().forEach(child => bottomRowEl.appendChild(child));
            
            // Render Bar Checkers
            drawBar(1);
            drawBar(2);

            // Update Off-Board Counts
            p1OffCountEl.textContent = BOARD_STATE[PLAYER_INFO[1].off].count;
            p2OffCountEl.textContent = BOARD_STATE[PLAYER_INFO[2].off].count;
        }

        function createPointElement(index, state) {
            const pointEl = document.createElement('div');
            pointEl.className = 'point';
            pointEl.dataset.point = index;
            pointEl.onclick = handlePointClick;

            // Optional: for debug/visualization:
            // pointEl.style.position = 'relative';
            // pointEl.innerHTML = `<span style="position:absolute; bottom:0; color:white; z-index:100; font-size:10px;">${index}</span>`; 

            // Add checker elements
            for (let i = 0; i < state.count; i++) {
                const checkerEl = document.createElement('div');
                checkerEl.className = `checker ${PLAYER_INFO[state.player].color}`;
                checkerEl.dataset.point = index;
                checkerEl.onclick = handleCheckerClick;
                
                // Show stack count if > 5
                if (state.count > 5 && i === 4) {
                    checkerEl.classList.add('stacked');
                    checkerEl.textContent = state.count;
                    pointEl.appendChild(checkerEl);
                    break; 
                } else if (state.count <= 5 || i < 5) {
                    pointEl.appendChild(checkerEl);
                }
            }
            return pointEl;
        }

        function drawBar(player) {
            const barEl = player === 1 ? barP1El : barP2El;
            const count = BOARD_STATE[PLAYER_INFO[player].bar].count;

            // Clear previous bar checkers (except text label)
            Array.from(barEl.children).filter(el => el.classList.contains('checker')).forEach(el => el.remove());
            
            for (let i = 0; i < count; i++) {
                const checkerEl = document.createElement('div');
                checkerEl.className = `checker bar-checker ${PLAYER_INFO[player].color}`;
                checkerEl.dataset.point = PLAYER_INFO[player].bar;
                checkerEl.onclick = handleCheckerClick;

                if (count > 5 && i === 4) {
                    checkerEl.classList.add('stacked');
                    checkerEl.textContent = count;
                    barEl.appendChild(checkerEl);
                    break;
                } else if (count <= 5 || i < 5) {
                    barEl.appendChild(checkerEl);
                }
            }
        }
        
        function updatePlayerInfo() {
            playerInfoEl.className = `p${currentPlayer}`;
            playerInfoEl.textContent = `${PLAYER_INFO[currentPlayer].name}'s Turn`;
        }

        function showMessage(title, text) {
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-text').textContent = text;
            document.getElementById('message-box').style.display = 'flex';
        }

        function hideMessage() {
            document.getElementById('message-box').style.display = 'none';
        }

        // --- DICE LOGIC ---

        function rollDice() {
            const d1 = Math.floor(Math.random() * 6) + 1;
            const d2 = Math.floor(Math.random() * 6) + 1;
            
            dice = [d1, d2];
            movesAvailable = [d1, d2];

            if (d1 === d2) {
                // Doubles: 4 moves
                movesAvailable = [d1, d1, d1, d1];
                gameMessageEl.textContent = `DOUBLES! Rolled ${d1}. You have 4 moves.`;
            } else {
                gameMessageEl.textContent = `Rolled ${d1} and ${d2}. Make your moves.`;
            }

            drawDice();
            rollDiceBtn.disabled = true;
            endTurnBtn.disabled = false;
        }

        function drawDice() {
            diceDisplayEl.innerHTML = '';
            movesAvailable.forEach((value, index) => {
                const diceEl = document.createElement('div');
                diceEl.className = 'dice';
                diceEl.dataset.value = value;
                diceEl.dataset.index = index;
                diceEl.textContent = value;
                diceDisplayEl.appendChild(diceEl);
            });
        }

        function markDiceUsed(usedValue) {
            let found = false;
            
            // Find the index of the first unused dice that matches the value
            const indexToMark = movesAvailable.findIndex((val, index) => val === usedValue && !diceDisplayEl.children[index].classList.contains('used'));

            if (indexToMark !== -1) {
                diceDisplayEl.children[indexToMark].classList.add('used');
                // Remove the value from movesAvailable (optional, but helps track remaining moves)
                movesAvailable[indexToMark] = 0; 
                found = true;
            }
            
            // Check if all moves are done
            if (movesAvailable.every(val => val === 0 || diceDisplayEl.children[movesAvailable.indexOf(val)].classList.contains('used'))) {
                setTimeout(endTurn, 500); // Automatically end turn if no moves left
            }

            return found;
        }
        
        // --- MOVEMENT VALIDATION ---

        function isHomeBoard(player, pointIndex) {
            const info = PLAYER_INFO[player];
            if (player === 1) {
                return pointIndex >= info.homeStart && pointIndex <= info.homeEnd;
            } else {
                return pointIndex >= info.homeStart && pointIndex <= info.homeEnd;
            }
        }

        function isPlayerReadyToBearOff(player) {
            let totalCheckersOnBoard = 0;
            const info = PLAYER_INFO[player];
            
            // Check bar
            if (BOARD_STATE[info.bar].count > 0) return false;

            // Check if any checkers are outside the home board
            for (let i = 1; i <= 24; i++) {
                if (BOARD_STATE[i].player === player && !isHomeBoard(player, i)) {
                    totalCheckersOnBoard += BOARD_STATE[i].count;
                }
            }
            
            // All checkers (15 total) minus those off-board must be in the home board.
            const totalOnHomeOrBar = 15 - BOARD_STATE[info.off].count;
            
            return totalCheckersOnBoard === 0;
        }

        function isValidMove(startPoint, endPoint) {
            const startState = BOARD_STATE[startPoint];
            const endState = BOARD_STATE[endPoint];
            const info = PLAYER_INFO[currentPlayer];
            const isFromBar = startPoint === info.bar;
            const isBearingOff = endPoint === info.off;
            const distance = Math.abs(endPoint - startPoint);
            
            // 1. Check if the checker belongs to the current player
            if (startState.player !== currentPlayer) return false;
            if (startState.count === 0) return false;

            // 2. Check Bar Rule: Must move from bar if checkers are on it
            if (BOARD_STATE[info.bar].count > 0 && !isFromBar) return false;

            // 3. Check Dice Match
            if (!movesAvailable.includes(distance)) {
                // Special check for bearing off (exact dice or dice overshoot)
                if (isBearingOff) {
                    const isHome = isHomeBoard(currentPlayer, startPoint);
                    const isMaxDice = Math.max(...movesAvailable) === distance;
                    
                    if (isPlayerReadyToBearOff(currentPlayer) && isHome) {
                        // Exact match OR Overshoot from last point
                        if (movesAvailable.includes(distance)) {
                            return true;
                        } else if (info.moveDir === 1 && startPoint === 6) { // P1's last point
                             return Math.max(...movesAvailable) > 6;
                        } else if (info.moveDir === -1 && startPoint === 19) { // P2's last point
                             return Math.max(...movesAvailable) > 6;
                        }
                    }
                }
                if (!movesAvailable.includes(distance)) return false;
            }

            // 4. Check End Point (Not bearing off)
            if (!isBearingOff) {
                // Cannot move to a point occupied by the opponent with 2 or more checkers (blocked)
                if (endState.player !== 0 && endState.player !== currentPlayer && endState.count >= 2) {
                    return false;
                }
            }

            // 5. Check Bearing Off Rules
            if (isBearingOff) {
                if (!isPlayerReadyToBearOff(currentPlayer)) return false;
                if (!isHomeBoard(currentPlayer, startPoint)) return false;
                
                // Overshooting allowed only from the farthest occupied point
                if (!movesAvailable.includes(distance)) {
                    // Find the furthest checker outside of the required distance
                    let furthestCheckerPoint = -1;
                    for (let i = info.homeStart; i <= info.homeEnd; i++) {
                        if (BOARD_STATE[i].player === currentPlayer && BOARD_STATE[i].count > 0) {
                            furthestCheckerPoint = i;
                        }
                    }
                    // Overshoot is only valid if the checker being moved is at the furthest point (or beyond the required distance for that dice)
                    if (startPoint !== furthestCheckerPoint) return false;
                    
                    // The used dice must be the largest available dice
                    if (distance !== Math.max(...movesAvailable)) return false;
                }
            }

            return true;
        }
        
        // --- MOVE EXECUTION ---
        
        function executeMove(startPoint, endPoint) {
            const startState = BOARD_STATE[startPoint];
            const endState = BOARD_STATE[endPoint];
            const info = PLAYER_INFO[currentPlayer];
            const distance = Math.abs(endPoint - startPoint);

            // 1. Mark the dice used
            if (endPoint !== info.off) {
                if (!markDiceUsed(distance)) {
                    gameMessageEl.textContent = "Error: Dice value not available for that move.";
                    return false;
                }
            } else {
                 // For bearing off, we must use the smallest valid dice that covers the distance
                const validDice = movesAvailable.filter(d => d >= distance);
                if (validDice.length > 0) {
                    const usedDice = Math.min(...validDice);
                    if (!markDiceUsed(usedDice)) {
                         gameMessageEl.textContent = "Error: Cannot bear off with available dice.";
                         return false;
                    }
                } else {
                     gameMessageEl.textContent = "Error: No dice can be used to bear off.";
                     return false;
                }
            }

            // 2. Handle hit (if not bearing off)
            if (endState.player !== 0 && endState.player !== currentPlayer && endState.count === 1) {
                const opponent = endState.player;
                const opponentBar = PLAYER_INFO[opponent].bar;
                
                // Move opponent checker to the bar
                BOARD_STATE[opponentBar].count++;
                
                // Clear the end point
                endState.player = currentPlayer; // New player takes the point
                endState.count = 1; 
                
                gameMessageEl.textContent = `${info.name} hit Player ${opponent} at point ${endPoint}!`;
            } else if (endPoint !== info.off) {
                // 3. Update end point (if not bearing off)
                endState.player = currentPlayer;
                endState.count++;
            } else {
                // 4. Handle bearing off (move to off-board)
                BOARD_STATE[info.off].count++;
                gameMessageEl.textContent = `${info.name} bore off a checker!`;
            }
            
            // 5. Update start point
            startState.count--;
            if (startState.count === 0) {
                startState.player = 0;
            }
            
            // 6. Check for Win
            if (BOARD_STATE[info.off].count === 15) {
                setTimeout(() => showMessage('Game Over!', `${info.name} wins the game!`), 100);
                rollDiceBtn.disabled = true;
                endTurnBtn.disabled = true;
            }

            // 7. Redraw and reset selection
            resetSelection();
            drawBoard();
            movesMade++;
            return true;
        }

        // --- UI HANDLERS ---

        function resetSelection() {
            if (selectedChecker) {
                const oldEl = document.querySelector(`.checker.selected`);
                if (oldEl) oldEl.classList.remove('selected');
                
                // Remove valid move highlights
                document.querySelectorAll('.point.valid-move').forEach(el => el.classList.remove('valid-move'));
            }
            selectedChecker = null;
        }

        function handleCheckerClick(event) {
            event.stopPropagation();
            
            if (rollDiceBtn.disabled === false) {
                 gameMessageEl.textContent = "Roll the dice first!";
                 return;
            }

            const pointIndex = parseInt(event.currentTarget.dataset.point);
            const state = BOARD_STATE[pointIndex];
            const info = PLAYER_INFO[currentPlayer];
            
            if (state.player !== currentPlayer) {
                 gameMessageEl.textContent = "That's not your checker!";
                 return;
            }
            
            // If the bar is not empty, only checkers on the bar can be selected.
            if (BOARD_STATE[info.bar].count > 0 && pointIndex !== info.bar) {
                 gameMessageEl.textContent = "You must move checkers off the bar first!";
                 return;
            }

            // Reset selection if the same checker is clicked
            if (selectedChecker === pointIndex) {
                resetSelection();
            } else {
                resetSelection(); // Clear existing highlights
                selectedChecker = pointIndex;
                event.currentTarget.classList.add('selected');
                highlightValidMoves(pointIndex);
            }
        }
        
        function handlePointClick(event) {
            const endPoint = parseInt(event.currentTarget.dataset.point);
            
            if (selectedChecker === null) {
                gameMessageEl.textContent = "Select a checker to move first.";
                return;
            }
            
            if (isValidMove(selectedChecker, endPoint)) {
                executeMove(selectedChecker, endPoint);
            } else {
                gameMessageEl.textContent = "Invalid move for the selected checker and dice.";
            }
        }
        
        function highlightValidMoves(startPoint) {
            const info = PLAYER_INFO[currentPlayer];
            
            // 1. Check moves to regular points
            const currentPoints = document.querySelectorAll('.point');
            currentPoints.forEach(pointEl => {
                const endPoint = parseInt(pointEl.dataset.point);
                if (isValidMove(startPoint, endPoint)) {
                    pointEl.classList.add('valid-move');
                }
            });

            // 2. Check move for bearing off
            if (isPlayerReadyToBearOff(currentPlayer)) {
                 if (isValidMove(startPoint, info.off)) {
                    const offEl = document.getElementById(info.off === 0 ? 'off-p1' : 'off-p2');
                    offEl.classList.add('valid-move');
                 }
            }
        }


        function endTurn() {
            resetSelection();
            
            // Check if any moves are left that COULD be played (A complex rule, simplifying for now)
            const remainingDice = movesAvailable.filter((val, index) => val > 0 && !diceDisplayEl.children[index].classList.contains('used'));
            
            if (remainingDice.length > 0) {
                 // Simple Check: If moves were made, allow end turn. If no moves were made, check if any move was possible.
                 // Complex Backgammon logic simplified: if the player gives up moves, that's their choice.
                 // A simple way to check if ANY move is available would require checking all 15 checkers against all dice combinations, which is extensive.
                 // For now, allow the end turn if moves were made or if the player chooses to pass.
                 
                 // If no moves were made, and dice are still available, inform the user they are passing moves.
                 if (movesMade === 0 && remainingDice.length > 0) {
                     gameMessageEl.textContent = `${PLAYER_INFO[currentPlayer].name} passes the remaining ${remainingDice.length} move(s).`;
                 } else if (remainingDice.length > 0) {
                     gameMessageEl.textContent = `${PLAYER_INFO[currentPlayer].name} passed the remaining dice.`;
                 }
            } else {
                 gameMessageEl.textContent = `${PLAYER_INFO[currentPlayer].name} completed all available moves.`;
            }

            // Switch Player
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            
            // Reset Turn State
            dice = [];
            movesAvailable = [];
            movesMade = 0;
            diceDisplayEl.innerHTML = '';
            
            updatePlayerInfo();
            rollDiceBtn.disabled = false;
            endTurnBtn.disabled = true;
        }


        // --- ENTRY POINT ---
        window.onload = initializeGame;

    </script>
</body>
</html>
